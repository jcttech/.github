name: 'Docker Build'
description: 'Build and push Docker image with SHA-based skip (supports Docker and Kaniko)'

inputs:
  registry:
    description: 'Container registry'
    required: false
    default: 'ghcr.io'
  image-name:
    description: 'Image name (defaults to repo name)'
    required: false
  sha:
    description: 'Commit SHA for tagging'
    required: true
  push:
    description: 'Push image to registry'
    required: false
    default: 'true'
  tag-prefix:
    description: 'Tag prefix to strip for semver extraction (e.g. "session-manager/")'
    required: false
    default: ''
  dockerfile:
    description: 'Path to Dockerfile'
    required: false
    default: 'Dockerfile'

outputs:
  image-exists:
    description: 'Whether image already existed'
    value: ${{ steps.check.outputs.exists }}
  tags:
    description: 'Applied tags'
    value: ${{ steps.meta.outputs.tags }}

runs:
  using: 'composite'
  steps:
    - name: Compute image reference
      id: image-ref
      shell: bash
      run: |
        if [ -n "${{ inputs.image-name }}" ]; then
          echo "name=${{ github.repository_owner }}/${{ inputs.image-name }}" >> $GITHUB_OUTPUT
        else
          echo "name=${{ github.repository }}" >> $GITHUB_OUTPUT
        fi

    - name: Detect builder
      id: detect
      shell: bash
      run: |
        if [ -x /kaniko/executor ]; then
          echo "builder=kaniko" >> $GITHUB_OUTPUT
        else
          echo "builder=docker" >> $GITHUB_OUTPUT
        fi

    - name: Check if image exists
      id: check
      shell: bash
      run: |
        IMAGE="${{ inputs.registry }}/${{ steps.image-ref.outputs.name }}"
        TAG="${{ inputs.sha }}"
        if [ "${{ steps.detect.outputs.builder }}" = "kaniko" ]; then
          # Use registry API to check (works without docker CLI)
          TOKEN=$(cat ~/.docker/config.json 2>/dev/null | grep -o '"auth":"[^"]*"' | head -1 | cut -d'"' -f4)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            "https://${{ inputs.registry }}/v2/${{ steps.image-ref.outputs.name }}/manifests/${TAG}" \
            -H "Accept: application/vnd.docker.distribution.manifest.v2+json")
          if [ "$STATUS" = "200" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        else
          if docker manifest inspect ${IMAGE}:${TAG} > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Set up Docker Buildx
      if: steps.check.outputs.exists != 'true' && steps.detect.outputs.builder == 'docker'
      uses: docker/setup-buildx-action@v3

    - name: Compute clean version
      if: startsWith(github.ref, 'refs/tags/')
      id: clean-ref
      shell: bash
      run: |
        REF_NAME="${GITHUB_REF_NAME}"
        PREFIX="${{ inputs.tag-prefix }}"
        echo "version=${REF_NAME#$PREFIX}" >> $GITHUB_OUTPUT

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ inputs.registry }}/${{ steps.image-ref.outputs.name }}
        tags: |
          type=sha,prefix=
          type=raw,value=latest,enable={{is_default_branch}}
          type=semver,pattern={{version}},value=${{ steps.clean-ref.outputs.version || '' }}
          type=semver,pattern={{major}}.{{minor}},value=${{ steps.clean-ref.outputs.version || '' }}
          type=semver,pattern={{major}},value=${{ steps.clean-ref.outputs.version || '' }},enable=${{ !startsWith(steps.clean-ref.outputs.version || 'v1', 'v0.') }}

    - name: Build and push (Docker)
      if: steps.check.outputs.exists != 'true' && inputs.push == 'true' && steps.detect.outputs.builder == 'docker'
      uses: docker/build-push-action@v6
      with:
        context: .
        file: ${{ inputs.dockerfile }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push (Kaniko)
      if: steps.check.outputs.exists != 'true' && inputs.push == 'true' && steps.detect.outputs.builder == 'kaniko'
      shell: bash
      env:
        META_TAGS: ${{ steps.meta.outputs.tags }}
      run: |
        # Use a writable temp dir for kaniko (non-root container)
        KANIKO_DIR=$(mktemp -d)
        mkdir -p "$KANIKO_DIR/.docker"
        cp ~/.docker/config.json "$KANIKO_DIR/.docker/config.json" 2>/dev/null || true

        # Build --destination flags from metadata tags
        DESTINATIONS=()
        while IFS= read -r tag; do
          [ -n "$tag" ] && DESTINATIONS+=("--destination=$tag")
        done <<< "$META_TAGS"

        echo "Building with ${#DESTINATIONS[@]} destination(s):"
        printf '  %s\n' "${DESTINATIONS[@]}"

        /kaniko/executor \
          --context="$GITHUB_WORKSPACE" \
          --dockerfile="${{ inputs.dockerfile }}" \
          --kaniko-dir="$KANIKO_DIR" \
          "${DESTINATIONS[@]}"

    - name: Retag existing image (Docker)
      if: steps.check.outputs.exists == 'true' && inputs.push == 'true' && steps.detect.outputs.builder == 'docker'
      shell: bash
      run: |
        SOURCE="${{ inputs.registry }}/${{ steps.image-ref.outputs.name }}:${{ inputs.sha }}"
        TAGS="${{ steps.meta.outputs.tags }}"
        TAG_ARGS=""
        for tag in $TAGS; do
          TAG_ARGS="${TAG_ARGS} -t ${tag}"
        done
        docker buildx imagetools create ${TAG_ARGS} ${SOURCE}

    - name: Retag existing image (Kaniko)
      if: steps.check.outputs.exists == 'true' && inputs.push == 'true' && steps.detect.outputs.builder == 'kaniko'
      shell: bash
      run: |
        echo "Image ${{ inputs.sha }} already exists, skipping rebuild"
        echo "Note: Kaniko does not support retagging without rebuild"
